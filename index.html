<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LittleBrett Platformer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      overflow: hidden;
    }
    canvas {
      display: block;
      background: url('bg.png') repeat-x center center;
      background-size: cover;
    }
    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <img id="startButton" src="btn_start.png" alt="Start Game" onclick="startGame()" />
  <canvas id="gameCanvas" width="1024" height="576"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const gravity = 1;
    let gameStarted = false;

    const images = {};
    const imageSources = {
      background: 'bg.png',
      brett_idle: 'brett_idle.png',
      brett_jump: 'brett_jump.png',
      brett_fall: 'brett_fall.png',
      brett_down: 'brett_down.png',
      brett_happy: 'brett_happy.png',
      platform_green: 'platform_green.png',
      coin: 'coin.png',
      btc: 'btc.png',
      eth: 'eth.png',
    };

    const keys = {
      right: false,
      left: false,
      up: false
    };

    let platforms = [];
    let coins = [];
    let player;
    let scrollOffset = 0;

    class Player {
      constructor() {
        this.width = 50;
        this.height = 50;
        this.x = 100;
        this.y = 300;
        this.dy = 0;
        this.dx = 0;
        this.speed = 5;
        this.jumpPower = 20;
        this.grounded = false;
      }

      draw() {
        const sprite = this.dy > 0 ? images.brett_fall : (this.dy < 0 ? images.brett_jump : images.brett_idle);
        ctx.drawImage(sprite, this.x, this.y, this.width, this.height);
      }

      update() {
        this.draw();
        this.y += this.dy;
        this.dy += gravity;

        if (keys.right) {
          this.dx = this.speed;
        } else if (keys.left) {
          this.dx = -this.speed;
        } else {
          this.dx = 0;
        }

        this.x += this.dx;
      }
    }

    class Platform {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 100;
        this.height = 20;
      }

      draw() {
        ctx.drawImage(images.platform_green, this.x, this.y, this.width, this.height);
      }
    }

    class Coin {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.size = 25;
        this.type = type;
      }

      draw() {
        ctx.drawImage(images[this.type], this.x, this.y, this.size, this.size);
      }
    }

    function init() {
      platforms = [];
      coins = [];
      scrollOffset = 0;

      // Create 50 platforms
      let x = 0;
      for (let i = 0; i < 50; i++) {
        const y = 300 + Math.random() * 50; // between 300-350
        platforms.push(new Platform(x, y));
        const coinType = i % 3 === 0 ? 'btc' : i % 3 === 1 ? 'eth' : 'coin';
        coins.push(new Coin(x + 35, y - 30, coinType));
        x += 120;
      }

      player = new Player();
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);

      platforms.forEach(platform => {
        platform.draw();
      });

      coins.forEach(coin => {
        coin.draw();
      });

      player.update();

      // Scroll world
      if (player.x > 500) {
        scrollOffset += player.dx;
        platforms.forEach(platform => platform.x -= player.dx);
        coins.forEach(coin => coin.x -= player.dx);
        player.x = 500;
      }

      // Collision with platforms
      player.grounded = false;
      platforms.forEach(platform => {
        if (
          player.y + player.height <= platform.y &&
          player.y + player.height + player.dy >= platform.y &&
          player.x + player.width >= platform.x &&
          player.x <= platform.x + platform.width
        ) {
          player.dy = 0;
          player.grounded = true;
        }
      });

      // Fall off
      if (player.y > canvas.height) {
        ctx.drawImage(images.brett_down, 400, 200, 200, 200);
        return;
      }

      // Win condition
      if (scrollOffset > 6000) {
        ctx.drawImage(images.brett_happy, 400, 200, 200, 200);
        return;
      }

      requestAnimationFrame(animate);
    }

    function startGame() {
      document.getElementById('startButton').style.display = 'none';
      init();
      animate();
      gameStarted = true;
    }

    window.addEventListener('keydown', (e) => {
      if (!gameStarted) return;
      switch (e.key) {
        case 'ArrowRight':
          keys.right = true;
          break;
        case 'ArrowLeft':
          keys.left = true;
          break;
        case ' ': // space
        case 'ArrowUp':
          if (player.grounded) {
            player.dy = -player.jumpPower;
            player.grounded = false;
          }
          break;
      }
    });

    window.addEventListener('keyup', (e) => {
      switch (e.key) {
        case 'ArrowRight':
          keys.right = false;
          break;
        case 'ArrowLeft':
          keys.left = false;
          break;
      }
    });

    // Load images
    let loaded = 0;
    const total = Object.keys(imageSources).length;
    Object.entries(imageSources).forEach(([key, src]) => {
      const img = new Image();
      img.src = src;
      img.onload = () => {
        loaded++;
        if (loaded === total) {
          document.getElementById('startButton').style.display = 'block';
        }
      };
      images[key] = img;
    });
  </script>
</body>
</html>
